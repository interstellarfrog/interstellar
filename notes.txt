Sentences in Quotes Are Copied From https://os.phil-opp.com/
Other Sentences Are Written In My Own Words

## Target Json file
This Is Used To Make A Custom Target For Building The OS As We Want To Run For Bare Metal
My Build
host: x86_64-pc-windows-msvc
release: 1.71.0-nightly

Target Build
To Avoid Linker Errors We Want To Cross Compile Our Code Using Our Custom Target.


# Instead Of Using The OS Default Linker We Use The Cross Platform LLD Linker That Comes With Rust
"linker-flavor": "ld.lld",
"linker": "rust-lld",

# Since We Cannot Unwind The Stack We Abort Instead
"panic-strategy": "abort",

# The Redzone Is An Area Below A Function (128 bytes) That Is Used For Temp Data But In Our Case That Will Overwrite Important Data That We Need
# For Example Interrupts Or Exceptions When They Happen The Data Inside Of The Redzone Will Be OverWritten And Will Cause The Function To Break - Stack Corruption
"disable-redzone": true,

# mmx And sse Is For SIMD Instructions Which Can Make Programs Faster But Using The SIMD Registers In Our Kernel Will Cause It To Slow Down
# As The Kernel Needs To Restore The Registers To Their Original State Before Continuing A Program After An Interrupt
# This Means That The Kernel Has To Save The Whole SIMD State To The Main Memory On Each System Call Or Hardware Interrupt
# But Since We Are Removing Support For The SSE Registers This Causes A Problem As The Rust Core Lib Uses These For Floats So We Add soft-float To Tell LLVM To Fix This
# Which Does Cause A Slight Slow Down But Should Be Faster Overall
"features": "-mmx,-sse,+soft-float",

## VGA Text Mode
Buffer Address Is Located at 0xb8000 for Color - Memory Mapped I/O
0xb0000 for monochrome
This Is The Easiest Way Of Printing To The Screen As All We Have To Do Is Write To A Memory Location Which In Turn Actually Writes 

## Volatile
In Future Rust Updates The Compiler Might Optimize The Code Even More So Our Writes To The VGA Buffer Might Be Removed By The Compiler
If It Does Not Think That It Is Needed - It Just Sees That We Are Writing To A Memory Location

"The volatile keyword indicates that a value may change between different accesses, even if it does not appear to be modified."
"This keyword prevents an optimizing compiler from optimizing away subsequent reads or writes and thus incorrectly reusing a stale value or omitting writes."

## Lazy Static
"To provide a global writer that can be used as an interface from other modules without carrying a Writer instance around, we try to create a static WRITER"
But This Fails Because Rusts Constant evaluator Can't Convert Raw Pointers Into References At Compile Time
So Instead We Use The Lazy Static Crate
"Instead of computing its value at compile time, the static lazily initializes itself when accessed for the first time. Thus, the initialization happens at runtime, so arbitrarily complex initialization code is possible."

## SpinLock
Used To Manage Access Between Shared Resources
Can Be Used To Lock A Resource And Other Programs Will Constantly Run A Loop Requesting Access (But It Will Only Run The Programs Loops Seperatly) 
And When The Program Is Free The Thread/Program Trying To Access It Will Be Given Access

## Testing 
When Running Custom Tests We Add #![reexport_test_harness_main = "test_main"] Because We Are Using No Main Which Also Means No Main For Tests So We Change The Name Then 

Any Tests In Test Folder Will Be Recognized Automatically

We Also Add This Which When Testing Append Args To QUEMU
[package.metadata.bootimage] 
test-args = ["-device", "isa-debug-exit,iobase=0xf4,iosize=0x04"]


Port 0xf4, 4 bytes
Then We Write A Number To This Port (0 or 1) 1 = "(1 << 1) | 1 = 3" 0 = "(0 << 1) | 1 = 1"
Which Will Either Exit With Success Or Error
We Use The x86_64 Crate To Do This


## CPU Exceptions
Exceptions Occur In A Bunch Of Different Ways - 0 Division, Accessing Invalid Memory Address ect.
An Exception Signal Means That Something Isn't Working In Given Instruction
There Are 32 CPU Exception Types  0 - 31
Most Common - Divide by zero, Invalid opcode, General protection fault, Page fault, Floating point exception



Exception Number	Exception Name	Description
0	                Divide by zero| The CPU tried to divide a number by zero.
1	                Debug exception|	The CPU received a debug event.
2	                NMI interrupt| The CPU received a non-maskable interrupt.
3	                Breakpoint exception| The CPU encountered a breakpoint instruction.
4	                Overflow exception| The CPU encountered an overflow error.
5	                Bounds check exception| The CPU tried to access an invalid memory location.
6	                Invalid opcode exception| The CPU tried to execute an invalid opcode.
7	                Coprocessor not available exception|	The CPU did not find a coprocessor.
8	                Double fault exception| The CPU encountered a second fault while handling a fault.
9	                Invalid TSS exception| The CPU tried to access an invalid task state segment.
10	                Segment not present exception| The CPU tried to access a segment that was not present.
11	                Stack fault exception| The CPU tried to access an invalid stack location.
12	                General protection fault exception| The CPU tried to access a memory location that it did not have permission to access.
13	                Page fault exception| The CPU tried to access a memory page that was not currently loaded into memory.
14	                Reserved	
15	                Floating point exception| The CPU encountered an error during the calculation of a floating point value.
16	                Alignment check exception| The CPU tried to access a memory location that was not aligned correctly.
17	                Machine check exception|	The CPU detected a hardware error.
18	                SIMD floating point exception| The CPU encountered an error during the calculation of a SIMD floating point value.
19	                Virtual interrupt error|	The CPU received a virtual interrupt that it did not expect.
20	                Input/output bound range exception| The CPU tried to access an input/output device that it did not have permission to access.
21	                Security exception| The CPU tried to access a memory location that was protected by the security system.
22-31	            Reserved	

#To Fix This Problem We Have To Set Up A Interrupt Descriptor Table

["
When an exception occurs, the CPU roughly does the following:

Push some registers on the stack, including the instruction pointer and the RFLAGS register. (We will use these values later in this post.)
Read the corresponding entry from the Interrupt Descriptor Table (IDT). For example, the CPU reads the 14th entry when a page fault occurs.
Check if the entry is present and, if not, raise a double fault.
Disable hardware interrupts if the entry is an interrupt gate (bit 40 not set).
Load the specified GDT selector into the CS (code segment).
Jump to the specified handler function.
"]

## Double Faults - number 8
Double Faults Happen When The Cpu Fails To Call The First Exception Handler
Double Faults Are Like Catch All {} - sometimes


## Interrupt Stack Table
The IST Is A Table Of Pointers - 7 To Stacks That We Know Are Good Stacks 

## Task State Segment -- Legacy Structure
Was Used To Hold Information About A Task In 32 Bit Mode And For Hardware Context Switching
But This Is No Longer Supported In 64 Bit Mode

New TSS =
Reserved u32
Privilege Stack Table [u64; 3] -- Ignore This Until We Have User Mode Programs
Reserved u64
IST [u64; 7]  -- 7 Pointers To Clean Stacks
Reserved u64
Reserved u16
I/O Map Base Address


## Global Descriptor Table
This Was Used Before Paging For Memory Management
"However, it is still needed in 64-bit mode for various things, such as kernel/user mode configuration or TSS loading."

## System Calls - From Chat GPT

The exact implementation details for setting up a system call interface can vary depending on your operating system and programming language. However, I can give you a general idea of how to do this in Rust.

Here's a high-level overview of the steps involved:

1. Define the interface for your system call: This involves defining the function signature for your kernel function that will be callable from user-space. You should specify the input parameters and the expected return value.

For example, let's say you want to create a system call that allows user-space code to get the current system time. You could define a function signature like this:

```rust
pub fn get_system_time() -> u64 {
    // implementation goes here
}
```

2. Allocate a system call number: In order to create a system call, you need to allocate a unique number that identifies it. This number will be used by user-space code to request the system call.

3. Implement the system call handler function: This is the function that will actually execute the kernel code for your system call. It should accept the input parameters from user-space, perform any necessary processing, and return the output value (if any).

For example, here's a simple implementation of the `get_system_time` function that returns the current system time as a 64-bit integer:

```rust
pub fn get_system_time() -> u64 {
    // Get the current time from the system clock
    let now = std::time::SystemTime::now();
    
    // Convert the time to a 64-bit integer and return it
    now.duration_since(std::time::UNIX_EPOCH)
        .unwrap()
        .as_secs()
}
```

4. Update the system call table: This involves adding an entry to the kernel's system call table that maps your system call number to the corresponding handler function.

In Rust, you can define a system call table as a static array of function pointers. For example:

```rust
static SYSCALL_TABLE: [Option<unsafe extern "C" fn() -> u64>; 1] = [
    Some(get_system_time),
];
```

In this example, we're defining a system call table with a single entry that maps system call number 0 to the `get_system_time` function.

5. Provide a user-space library function: Finally, you need to provide a library function that user-space code can call to trigger your system call. This library function should use inline assembly to execute the software interrupt instruction and pass the appropriate system call number and arguments to the kernel.

Here's an example of a library function that calls the `get_system_time` system call:

```rust
pub fn get_system_time() -> u64 {
    let result: u64;
    
    unsafe {
        // Execute the software interrupt instruction to trigger the system call
        asm!(
            "int 0x80",
            inout("rax") 0,
            lateout("rdx") result,
            options(nostack),
        );
    }
    
    result
}
```

In this example, we're using inline assembly to execute the `int 0x80` instruction, which is the software interrupt instruction on x86 architectures. We're passing the system call number (0) in the `rax` register and expecting the return value to be passed back in the `rdx` register.

That's a general overview of how to create a system call interface in Rust. Keep in mind that the exact details can vary depending on your specific use case and operating system. Additionally, system calls can be a powerful but potentially dangerous feature, so you should take care to ensure that your system call interface is secure and well-audited.














# System Call Table More Info - From Chat-GPT

To make the system call table work, we need to perform the following steps:

1. Define the system call function: We need to define the function that will be called when a system call is made. This function should take a pointer to the system call parameters as its input, and it should return the result of the system call.

2. Assign an index to the system call: Each system call should have a unique index, which will be used to identify the system call when it is invoked.

3. Update the system call table: We need to update the system call table with the index and the function pointer for each system call. This is typically done during the kernel initialization process.

4. Implement the system call dispatcher: When a system call is invoked, the system call dispatcher is called. This function reads the system call index from the appropriate CPU register, looks up the corresponding function pointer in the system call table, and calls the function with the system call parameters.

Here is some sample code in Rust that demonstrates how to update the system call table and implement a simple system call function:

```rust
// Define the system call function
fn my_syscall(params: *mut u64) -> u64 {
    // Implement the system call logic here
    return 0; // Return the result of the system call
}

// Assign an index to the system call
const MY_SYSCALL_INDEX: u64 = 42;

// Update the system call table
static mut SYSTEM_CALL_TABLE: [Option<unsafe fn(*mut u64) -> u64>; 256] = [None; 256];
unsafe {
    SYSTEM_CALL_TABLE[MY_SYSCALL_INDEX as usize] = Some(my_syscall);
}

// Implement the system call dispatcher
#[naked]
pub unsafe extern "C" fn syscall_dispatcher() {
    // Read the system call index from the appropriate CPU register
    let syscall_index: u64;
    asm!("mov %r10, $0" : "=r" (syscall_index));

    // Look up the corresponding function pointer in the system call table
    let syscall_fn: unsafe fn(*mut u64) -> u64;
    syscall_fn = SYSTEM_CALL_TABLE[syscall_index as usize].unwrap();

    // Call the function with the system call parameters
    let params: *mut u64;
    asm!("mov %r11, $0" : "=r" (params));
    let result = syscall_fn(params);

    // Return the result of the system call
    asm!("mov $0, %rax" : "=r" (result));
    asm!("ret");
}
```

Note that this code is just an example, and it may not work exactly as is in your particular OS. You will need to customize it to fit your specific needs and requirements.