Sentences in Quotes Are Copied From https://os.phil-opp.com/
Other Sentences Are Written In My Own Words

## Target Json file
This Is Used To Make A Custom Target For Building The OS As We Want To Run For Bare Metal
My Build
host: x86_64-pc-windows-msvc
release: 1.71.0-nightly

Target Build
To Avoid Linker Errors We Want To Cross Compile Our Code Using Our Custom Target.


# Instead Of Using The OS Default Linker We Use The Cross Platform LLD Linker That Comes With Rust
"linker-flavor": "ld.lld",
"linker": "rust-lld",

# Since We Cannot Unwind The Stack We Abort Instead
"panic-strategy": "abort",

# The Redzone Is An Area Below A Function (128 bytes) That Is Used For Temp Data But In Our Case That Will Overwrite Important Data That We Need
# For Example Interrupts Or Exceptions When They Happen The Data Inside Of The Redzone Will Be OverWritten And Will Cause The Function To Break - Stack Corruption
"disable-redzone": true,

# mmx And sse Is For SIMD Instructions Which Can Make Programs Faster But Using The SIMD Registers In Our Kernel Will Cause It To Slow Down
# As The Kernel Needs To Restore The Registers To Their Original State Before Continuing A Program After An Interrupt
# This Means That The Kernel Has To Save The Whole SIMD State To The Main Memory On Each System Call Or Hardware Interrupt
# But Since We Are Removing Support For The SSE Registers This Causes A Problem As The Rust Core Lib Uses These For Floats So We Add soft-float To Tell LLVM To Fix This
# Which Does Cause A Slight Slow Down But Should Be Faster Overall
"features": "-mmx,-sse,+soft-float",

## VGA Text Mode
Buffer Address Is Located at 0xb8000 for Color - Memory Mapped I/O
0xb0000 for monochrome
This Is The Easiest Way Of Printing To The Screen As All We Have To Do Is Write To A Memory Location Which In Turn Actually Writes 

## Volatile
In Future Rust Updates The Compiler Might Optimize The Code Even More So Our Writes To The VGA Buffer Might Be Removed By The Compiler
If It Does Not Think That It Is Needed - It Just Sees That We Are Writing To A Memory Location

"The volatile keyword indicates that a value may change between different accesses, even if it does not appear to be modified."
"This keyword prevents an optimizing compiler from optimizing away subsequent reads or writes and thus incorrectly reusing a stale value or omitting writes."

## Lazy Static
"To provide a global writer that can be used as an interface from other modules without carrying a Writer instance around, we try to create a static WRITER"
But This Fails Because Rusts Constant evaluator Can't Convert Raw Pointers Into References At Compile Time
So Instead We Use The Lazy Static Crate
"Instead of computing its value at compile time, the static lazily initializes itself when accessed for the first time. Thus, the initialization happens at runtime, so arbitrarily complex initialization code is possible."

## SpinLock
Used To Manage Access Between Shared Resources
Can Be Used To Lock A Resource And Other Programs Will Constantly Run A Loop Requesting Access (But It Will Only Run The Programs Loops Seperatly) 
And When The Program Is Free The Thread/Program Trying To Access It Will Be Given Access

## Testing 
When Running Custom Tests We Add #![reexport_test_harness_main = "test_main"] Because We Are Using No Main Which Also Means No Main For Tests So We Change The Name Then 

Any Tests In Test Folder Will Be Recognized Automatically

We Also Add This Which When Testing Append Args To QUEMU
[package.metadata.bootimage] 
test-args = ["-device", "isa-debug-exit,iobase=0xf4,iosize=0x04"]


Port 0xf4, 4 bytes
Then We Write A Number To This Port (0 or 1) 1 = "(1 << 1) | 1 = 3" 0 = "(0 << 1) | 1 = 1"
Which Will Either Exit With Success Or Error
We Use The x86_64 Crate To Do This


## CPU Exceptions
Exceptions Occur In A Bunch Of Different Ways - 0 Division, Accessing Invalid Memory Address ect.
An Exception Signal Means That Something Isn't Working In Given Instruction
There Are 32 CPU Exception Types  0 - 31
Most Common - Divide by zero, Invalid opcode, General protection fault, Page fault, Floating point exception



Exception Number	Exception Name	Description
0	                Divide by zero| The CPU tried to divide a number by zero.
1	                Debug exception|	The CPU received a debug event.
2	                NMI interrupt| The CPU received a non-maskable interrupt.
3	                Breakpoint exception| The CPU encountered a breakpoint instruction.
4	                Overflow exception| The CPU encountered an overflow error.
5	                Bounds check exception| The CPU tried to access an invalid memory location.
6	                Invalid opcode exception| The CPU tried to execute an invalid opcode.
7	                Coprocessor not available exception|	The CPU did not find a coprocessor.
8	                Double fault exception| The CPU encountered a second fault while handling a fault.
9	                Invalid TSS exception| The CPU tried to access an invalid task state segment.
10	                Segment not present exception| The CPU tried to access a segment that was not present.
11	                Stack fault exception| The CPU tried to access an invalid stack location.
12	                General protection fault exception| The CPU tried to access a memory location that it did not have permission to access.
13	                Page fault exception| The CPU tried to access a memory page that was not currently loaded into memory.
14	                Reserved	
15	                Floating point exception| The CPU encountered an error during the calculation of a floating point value.
16	                Alignment check exception| The CPU tried to access a memory location that was not aligned correctly.
17	                Machine check exception|	The CPU detected a hardware error.
18	                SIMD floating point exception| The CPU encountered an error during the calculation of a SIMD floating point value.
19	                Virtual interrupt error|	The CPU received a virtual interrupt that it did not expect.
20	                Input/output bound range exception| The CPU tried to access an input/output device that it did not have permission to access.
21	                Security exception| The CPU tried to access a memory location that was protected by the security system.
22-31	            Reserved	

#To Fix This Problem We Have To Set Up A Interrupt Descriptor Table

["
When an exception occurs, the CPU roughly does the following:

Push some registers on the stack, including the instruction pointer and the RFLAGS register. (We will use these values later in this post.)
Read the corresponding entry from the Interrupt Descriptor Table (IDT). For example, the CPU reads the 14th entry when a page fault occurs.
Check if the entry is present and, if not, raise a double fault.
Disable hardware interrupts if the entry is an interrupt gate (bit 40 not set).
Load the specified GDT selector into the CS (code segment).
Jump to the specified handler function.
"]


